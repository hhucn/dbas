========
Database
========


General
=======

D-BAS uses a session scope during the work with the database. The concept of session scopes was introduced, with an
emphasis on web applications and the practice of linking the scope of a Session with that of a web request.

We also use __pyramid_tm__ to manage transaction automatically, because Pyramid view code usually doesn't manage
transactions. In addition manually executed transactions are needed, if you want to force the session to write the
edited values **now**.

Normally this behaviour is not needed but since we are editing arguments/statements/... and want to get their text at
another places of the program, we have to force transactions sometimes.

Guest-User
==========

+-------------------+-------------------+------------------------+-------------------+
|**Mode**           | **Name**          | **Password**           | **Permission**    |
+-------------------+-------------------+------------------------+-------------------+
| development       | guest             | guest                  | read-only         |
+-------------------+-------------------+------------------------+-------------------+
| production        | guest             | Ask: ``dbas@cs.hhu.de``| read-only         |
+-------------------+-------------------+------------------------+-------------------+

The D-BAS database has one guest user.
The name of the guest user is ``guest``.
The live database can be accessed from the university network.
In order to access the live data, a password for the guest user must be requested.
The password can be requested under ``dbas@cs.hhu.de``.

For local development the password for the guest user is: ``guest``.

The guest user has the exclusive right to ``SELECT`` the essential database tables. This includes:

+--------------------+
|issues              |
+--------------------+
|languages           |
+--------------------+
|premisegroups       |
+--------------------+
|premises            |
+--------------------+
|statement_to_issue  |
+--------------------+
|statements          |
+--------------------+
|textversions        |
+--------------------+

The guest user may also access the ``View`` ``public_nicknames``.
This view includes the ``uid`` of the users and their ``public_nickname``.
If the real-time data is required, it can be requested remotely with the guest user.
The database can be accessed under ``dbas.cs.uni-duesseldorf.de`` or ``dbas.hhu.de`` via port ``5432``.

Dump a database
===============

Current database can be saved via::

    $ docker exec dbas_db_1 pg_dumpall -U postgres > /some/path/for/saving/database.sql

To use this dump as an entrypoint, you have to remove the root user from the database with::

    $ sed -e '/CREATE ROLE postgres/d' \
          -e '/ALTER ROLE postgres/d' \
          -i /some/path/for/saving/database.sql

Working with Migrations
=======================
We are using ``alembic`` for database migrations.
These migrations are saved in so called *revisions* inside the ``migrations/versions`` directory.

tl;wr
-----
- ``alembic revision --autogenerate -m "Add table X"`` To generate a migration file. You may want check them.
- ``alembic history``
- ``alembic upgrade head`` Upgrade the DB to latest

Create a new migration
----------------------
If the database models are touched, a new revision has to be generated.
Make sure, that the database itself is clean.
The revision itself is generated by ``alembic revision --autogenerate -m "Add table X"``.
You may have to check if there was any error while generating.
(Example: The generation was faulty, because the database had a circular dependency.)
Test your new revision by up- and downgrading the database with:
``alembic upgrade +1`` and ``alembic downgrade -1``.
Upgrade to the latest revision with ``alembic upgrade head``.

Merging migrations
------------------
There are two ways to merge migrations.
They are comparable to rebase and merge from git.
The first one is like merge. Use ``alembic merge head`` to merge all head revisions into a new revision.
The other one is like rebase.
You have to change the ``down-revision`` in your newest revision to the id of the conflicting revision.
This way you sort them out.


Setup the database for migration
--------------------------------
*alembic* creates a table with just the current revision version as content.
To set this initial version use ``alembic stamp 2a4bc7c8ff38``.
Revision ``2a4bc7c8ff38`` is the state of the *discussion* database, as the alembic migrations are introduced.

Generate a SQL-Migrations
-------------------------
It is possible to generate just a SQL-File for migration. Just add ``--sql`` to the ``alembic upgrade`` command.

Manual migrations
-----------------
This is a collection of scripts to migrate old databases to a new version, located in ``docker/db/migrations``.
The changes in this scripts are likely to be out of the scope of alembic.
The scripts are in directorys named like the version to upgrade to.
For clarification of the execution order, the scripts are prefixed with strict increasing integers.
The scripts are supposed to be run inside the db container.

:v1.4.4:
    This version of D-BAS introduces *alembic* as the migration manager for model migrations.
    The migrations ...

    1. remove a circular dependency. (*SQLAlchemy* and *alembic* doesn't like them, neither should we)
    #. move the content of the old news database to the discussion database (Now there is only one database)
    #. move the old content of the news datsbase into it's own schema.
    #. stamp the database to the base revision of D-BAS 1.4.4.


:v1.5.1:
    This version of D-BAS removes all other database users except ``postgres``, since the database isn't shared between programs and the other users have no use.
    The migration will transfer the ownership of all tables to the ``postgres`` user and drops the four old roles.


Steps for creating a new database
=================================

1. Remove all `*.sql`-files in `docker/db/entrypoint`.
2. Remove the `.bak` ending of the `001_init`-script in `docker/db`. This will create a fresh and empty database.
3. Be sure, that you deleted your old `dbas_db_1`-container.
4. Run `docker-compose up`.
5. Execute some initialization methods which are already given, like creating an English and German discussion as well as news::

    $ docker exec dbas_web_1 init_field_test_sql development.ini
    $ docker exec dbas_web_1 init_news_sql development.ini
    $ docker exec dbas_web_1 init_dummyvotes_sql development.ini

At this point you have created the same data like in `002_development_seed.sql`. If needed, you can just add you own
settings in `database/initializedb.py`.


.. deprecated:: 1.3.1
   This comes from the good ol' times where we manually set up a database. We are now using Docker and its entrypoint
   scripts simplify the seeding process.

1. Add a console script under console_scripts in setup.py.
2. Specify path for the database in development.ini and production.ini.
3. Load database in dbas/__init__.py.
4. Add session, engine and methods in dbas/database/__init__.py.
5. Define a new model <new_model>.py in dbas/database/.
6. Define a function for creation in dbas/database/initializedb.py. Name of the method is the same as in the console script
7. Optional: add dummy data in dbas/database/initializedb.py.
8. Call

.. code-block:: console

    $ python setup.py develop
    $ <console_script_name> development.ini

======================
Source-Code Docstrings
======================

Description
===========

.. automodule:: dbas.database
    :members:


Discussion Model
================

.. automodule:: dbas.database.discussion_model
    :members:


Initialize Dummy DB
===================

.. automodule:: dbas.database.initializedb
    :members:
